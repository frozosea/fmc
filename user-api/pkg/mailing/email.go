package mailing

import (
	"context"
	"fmt"
	"gopkg.in/gomail.v2"
	"net/http"
	"net/smtp"
	"net/url"
	"sync"
)

type loginAuth struct {
	username, password string
}

func LoginAuth(username, password string) smtp.Auth {
	return &loginAuth{username, password}
}

func (a *loginAuth) Start(server *smtp.ServerInfo) (string, []byte, error) {
	// return "LOGIN", []byte{}, nil
	return "LOGIN", []byte(a.username), nil
}

func (a *loginAuth) Next(fromServer []byte, more bool) ([]byte, error) {
	if more {
		switch string(fromServer) {
		case "Username:":
			return []byte(a.username), nil
		case "Password:":
			return []byte(a.password), nil
		}
	}
	return nil, nil
}

type IMailing interface {
	SendSimple(ctx context.Context, toAddresses []string, subject, body, textType string) error
}

type Mailing struct {
	smtpHost  string
	smtpPort  int
	fromEmail string
	password  string
	authKey   string
}

func NewMailing(smtpHost string, smtpPort int, fromEmail string, password string, authKey string) *Mailing {
	return &Mailing{smtpHost: smtpHost, smtpPort: smtpPort, fromEmail: fromEmail, password: password, authKey: authKey}
}
func (w *Mailing) getUrlValues(subject, toEmail, body string) (url.Values, error) {
	r := url.Values{}
	r.Add("from", w.fromEmail)
	r.Add("subject", subject)
	//r.Add("text", body)
	r.Add("to", toEmail)
	r.Add("html", fmt.Sprintf(`<html><head></head><body><div>%s</div>/body></html>`, body))
	return r, nil
}
func (w *Mailing) getRequest(ctx context.Context, subject, toEmail, body string) (*http.Request, error) {
	// Generated by curl-to-Go: https://mholt.github.io/curl-to-go

	req, err := http.NewRequest("POST", "https://api.smtp.bz/v1/smtp/send", nil)
	if err != nil {
		return nil, err
	}
	values, err := w.getUrlValues(subject, toEmail, body)
	if err != nil {
		return nil, err
	}
	req.PostForm = values
	req.Header.Set("Authorization", w.authKey)
	req.Header.Set("Content-Type", "multipart/form-data")
	return req, nil
}
func (w *Mailing) SendSimple(ctx context.Context, toAddress []string, subject, message, textType string) error {
	errCh := make(chan error, 1)
	var wg sync.WaitGroup
	for _, toEmail := range toAddress {
		wg.Add(1)
		go func() {
			defer wg.Done()
			m := gomail.NewMessage()
			m.SetHeader("From", w.fromEmail)
			m.SetHeader("To", toEmail)
			m.SetHeader("Subject", subject)
			m.SetBody(textType, message)
			d := gomail.NewDialer(w.smtpHost, w.smtpPort, w.fromEmail, w.password)
			if err := d.DialAndSend(m); err != nil {
				errCh <- err
			}
		}()
		wg.Wait()
	}
	for {
		select {
		case <-ctx.Done():
			return nil
		case err := <-errCh:
			return err
		default:
			return nil
		}
	}
	//m := []byte("From: john.doe@example.com\r\n" +
	//	fmt.Sprintf("To: %s\r\n", strings.Join(toAddress, ",")) +
	//	fmt.Sprintf("Subject: %s\r\n\r\n", subject) +
	//	fmt.Sprintf("%s\r\n", message))
	//auth := LoginAuth(w.fromEmail, w.password)
	//return smtp.SendMail(fmt.Sprintf(`%s:%d`, w.smtpHost, w.smtpPort), auth, w.fromEmail, toAddress, m)
	//m := gomail.NewMessage()
	//m.SetHeaders(map[string][]string{
	//	"From":    {w.fromEmail},
	//	"To":      toAddress,
	//	"Subject": {subject},
	//})
	//m.SetHeader("From", w.fromEmail)
	//m.SetHeader("Cc", toAddress...)
	//m.SetHeader("Subject", subject)
	//m.SetBody(textType, message)
	//d := gomail.NewDialer(w.smtpHost, w.smtpPort, w.fromEmail, w.password)
	//return d.DialAndSend(m)
}
